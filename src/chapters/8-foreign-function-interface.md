# 外部関数インターフェイス

外部関数インターフェイス(FFI)には2つの目的がある。(1)Haskellにおいて外部の言語の機能へのインターフェイスを記述できるようにすることと、(2)外部コードからHaskellの所定の手続きを利用できるようにすることである。より一般的には、その目的はHaskellとほかの言語を混ぜてプログラムの実装が書けるようにすることであり、その結果として、ソースコードがアーキテクチャやOSから独立するように、HaskellとHaskellでないシステムでの異なる実装を跨いだ移植性をソースコードが持つようにすることである。

## 外部言語

HaskellのFFIは現状、Haskellのコードと外部コードの間のやり取りをC言語の呼び出し規約に沿った形でしか指定できない。しかし、FFIは現在の定義を他の言語(C++やJavaなど)の呼び出し規約を含むようにモジュール拡張が可能な形でデザインされている。それらの言語のサポートの正確な定義は、Haskellの将来的なバージョンに含められることが期待される。2つ目の大きな省略は、外部言語におけるマルチスレッド(特にスレッドローカルの扱い)とのやり取りの定義である。よってこれらの詳細は現状では処理系定義である。

現在の仕様のコアは、Haskellと接続するのに使われる外部言語とは独立である。しかし、FFIの規格が言語依存に必ずなる2つの領域がある。(1)外部名称の規格と(2)外部言語の基本型のマーシャリングである。前者の例として、次のことを考えてみよ。C言語においては単純な識別子はオブジェクトを同定するのに十分である[9]が、一方でJavaでは、一般に可能なオーバーローディングの解決のために、修飾子付きの名前を引数と戻り値型を組み合わせたものが必要になる[5]。2つ目の点に関しては、多くの言語では一部の基本型の正確な表現を与えていないことを考えよ。例えばC言語における`int`型は16または32または64bit長である。同様に、Haskellも`Int`は少なくとも<code>[-2<sup>29</sup>,2<sup>29</sup>-1]</code>の範囲に渡ることしか保証していない(セクション[6.4](./6-predefined-types-and-classes.md)参照)。結果として、C言語の`int`の値が確かにHaskellで表現できるようにするために、`int`の表現と合っていることを保証してくれるような新しい型`CInt`を導入しなければならない。

外部名称の企画は呼び出し規約依存であるが、セクション[8.5](./8-foreign-function-interface.md)で説明される。また、外部言語に基づいた基本型のマーシャリングはセクション[8.6](./8-foreign-function-interface.md)で説明される。

## 文脈

与えられたHaskellのシステムに対して、我々は**Haskell文脈**というものを、Haskellのシステムの基礎となっている抽象機械の実行文脈と定義する。これは抽象機械のヒープ、スタック、レジスタと言ったものと、およびその具体的なアーキテクチャへの対応も含む。他の実行文脈は**外部文脈**と呼ぶ。一般に、Haskell文脈と与えられた外部文脈の間のデータフォーマットや呼び出し規約にはどんな互換性も仮定できない。ただしHaskellが明示的に特定のデータフォーマットを指定していた場合を除く。

外部関数インターフェイスの主要なゴールは、Haskell文脈と外部文脈の間にプログラム可能なインターフェイスを提供することである。結果としてHaskellのスレッドは外部文脈のデータにアクセスすることができ、外部文脈の中で関数を呼ぶことやまたその逆もできる。以下の定義では、外部文脈は通常呼び出し規約によって特定されるものとする。

### 言語間の型の一貫性

静的型をサポートする多くの外部言語が与えられたとき、Haskellの型の外部言語の型に対する一貫性が外部関数に対して強制できるかどうかという疑問がある。不幸にもこれは、一般には、Haskellシステムの実装者側による重大な投資(すなわち、専用の型チェッカーの実装)がなければ不可能である。例えば、C言語の呼び出し規約の場合には、他の唯一の方法はC言語のプロトタイプ宣言をHaskellの型から生成し、それをC言語のコンパイラにこのプロトタイプとインポートされた関数の記述されたC言語のヘッダーファイルで指定されたプロトタイプとをマッチさせることである。しかしながら、Haskellの型はこの方法を追求するには一部の情報がかけているのである。特に、Haskellの型はいつ`const`修飾子が必要になるかに関する情報を含んでいない。

結果として、ここでの定義はHaskellのシステムに外部型との一貫性をチェックすることを要求しない。しかしながら、Haskellのシステムは、理不尽な努力を要しない任意の言語との間で型の一貫性をチェックする方法を提供することが推奨される。

## 字句構造

FFIは単一のキーワード`foreign`と特別な識別子の集合を予約する。後者は外部宣言の中でのみ特別な意味を持つが、他の場所では通常の識別子として使われるだろう。

特別な識別子`ccall, cplusplus, dotnet, jvm, stdcall`は呼び出し規約を記述するために定義されている。しかし、FFIの具体的な実装は自由に、特定のシステムの呼び出し規約でここでは明示的にリストアップされていないものを追加でサポートしてよい。

外部のC言語文脈のオブジェクトを参照するために、次の句を導入する。

|||||
|--|--|--|--|
|<em>chname</em>|→|{<em>chchar</em>} `. h`|(C header filename)|
|<em>cid</em>|→|<em>letter</em> {<em>letter</em> &#124; <em>ascDigit</em>}|(C identifier)|
|<em>chchar</em>|→|<em>letter</em> &#124; <em>ascSymbol</em><sub>⟨`&`⟩</sub>| |
|<em>letter</em>|→|<em>ascSmall</em> &#124; <em>ascLarge</em> &#124; `_`| |

<em>chname</em>で利用できる語彙素の範囲として、C言語における`#include`ディレクティブの引数として許容されているもののサブセットが許容されている。特に、ファイル名<em>chname</em>は`.h`を語尾に持たなければならない。<em>cid</em>によって生成される語彙素はC言語の識別子として許容されるものと一致する。具体的には[9]をみよ。

## 外部宣言

外部宣言の文法は次である。

|||||
|--|--|--|--|
|<em>topdecl</em>|→|`foreign` <em>fdecl</em>| |
|<em>fdecl</em>|→|`import` <em>callconv</em> [<em>safety</em>] <em>impent</em> <em>var</em> `::` <em>ftype</em>|(define variable)|
| |&#124;|`export` <em>callconv</em> <em>expent</em> <em>var</em> `::` <em>ftype</em>|(expose variable)|
|<em>callconv</em>|→|`ccall` &#124; `stdcall` &#124; `cplusplus`|(calling convention)|
| |&#124;|`jvm` &#124; `dotnet`| |
| |&#124;|**system-specific calling conventions**| |
|<em>impent</em>|→|[<em>string</em>]| |
|<em>expent</em>|→|[<em>string</em>]| |
|<em>safety<em>|→|`unsafe` &#124; `safe`| |

外部宣言には2つの要素がある、import宣言とexport宣言である。import宣言は**外部エンティティ**すなわち外部文脈で定義された関数やメモリ位置をHaskell文脈の中で利用可能にするものである。逆に、export宣言はHaskell文脈の関数を外部文脈の外部エンティティとして定義する。結果として、この2種類の宣言は、import宣言が新しい変数を宣言するのに対し、export宣言はHaskelllモジュールですでに定義された変数を用いるという点で異なる。

外部エンティティを含む外部文脈は外部宣言で与えられた呼び出し規約によって決定される。結果として、外部エンティティの仕様の正確なところは呼び出し規約とそれがimport宣言の中に(<em>impent</em>として)現れるかどうか、あるいはexport宣言の中に(<em>expent</em>として)現れるかどうか、の両方に依存する。異なる呼び出し規約の存在がある中で文法を一律に与えるために、外部エンティティの記述は字句構造としてはHaskellの文字列語彙素として現れることが保証されているものとする。唯一の例外はこの文字列が空文字列である(すなわち、`""`の形をしている)ときである。この場合には、文字列全体は省略できるものとする。

### 呼び出し規約

与えられたアーキテクチャにおける外部エンティティのバイナリインターフェイスは呼び出し規約によって決定される。それはしばしば外部エンティティが実装されているプログラミング言語にも依存するが、通常はより強く外部エンティティがコンパイルされているシステムの方に依存する。

どのようにして呼び出し規約がプログラミング言語よりシステムの方にむしろ支配されるかということの例として、Javaの抽象マシン(JVM)[11]へ向けてバイトコードにコンパイルされたエンティティは、それが実装されているソース言語(このエンティティは例えばOberonによって実装されているかもしれない)よりもむしろJVMの規則に従って呼ばれなければならないであろう。

HaskellのFFIのいかなる実装も、`ccall`で表されるC言語の呼び出し規約は少なくとも実装しなければならない。他の全ての呼び出し規約は任意である。一般に、呼び出し規約の集合はオープンである、すなわち、各実装は呼び出し規約を選んで追加でサポートする場合がある。`ccall`に加えて、テーブル8.1は一般的な呼び出し規約の識別子を整理したものである。

|識別子|表現された呼び出し規約|
|--|--|
|`ccall`|システムの標準的なCコンパイラの呼び出し規約|
|`cplusplus`|システムの標準的なC++コンパイラの呼び出し規約|
|`dotnet`|`.NET`プラットフォームの呼び出し規約|
|`jvm`|Javaの抽象マシンの呼び出し規約|
|`stdcall`|(Pascal規約に準拠した)Win32 APIの呼び出し規約|

実装はこれらの規約を全て実装する必要はないが、いずれかを実装するのであれば上に書かれた名前を使うべきである。他の呼び出し規約については、実装は自由に適切な名前を選ぶことができる。

`ccall`と`stdcall`の呼び出し規約のセマンティクスのみがここでは定義されている。より多くの呼び出し規約がHaskellの将来のバージョンで追加されることであろう。

特定の呼び出し規約を実装するHaskellシステムによって生成されたコードは、そのシステムの対象となるコードによって広く変化する可能性があることには注意すべきであろう。例えば、呼び出し規約`jvm`はJavaコードを生成するHaskellコンパイラが実装するには自明なものであるが、一方でCコードを生成するHaskellコンパイラにとってはJavaのネイティブインターフェイス(JNI)[10]がターゲットとなるべきであろう。

### 外部型

以下の型の集合は**基本外部型**を構成する。

- Haskellの`Prelude`がエクスポートするものと同様の`Char, Int, Double, Float, Bool`
- `Foreign`(セクション24)によってエクスポートされる、`Int8, Int16, Int32, Int64, Word8, Word16, Word32, Word64`と任意の型`a`に対する`Ptr a, FunPtr a, StablePtr a`

FFIを実装するHaskellシステムはこれらの型をHaskellと外部文脈の間で、関数の引数や結果としてやり取りできるようにする必要がある。

外部型は次の文法によって生成される。

||||
|--|--|--|--|
|<em>ftype</em>|→|<em>frtype</em>| |
| |&#124;|<em>fatype</em> → <em>ftype</em>| |
|<em>frtype</em>|→|<em>fatype</em>| |
| |&#124;|`()`| |
|<em>fatype</em>|→|<em>qtycon</em> <em>atype</em><sub>1</sub> … <em>atype</em><sub>k</sub>| (<em>k</em> ≥ 0)|

外部型とは、外部エンティティのHaskellにおける型である。Haskellの型の一部分のみが外部型として認められているが、これはHaskell文脈と外部文脈の間で標準的な方法により転送可能であるのは型の制限された部分のみであることによるものである。外部型は<em>n</em> ≥ 0として、<code><em>at</em><sub>1</sub> -> ⋅⋅⋅ -> <em>at</em><sub>n</sub> -> <em>rt</em></code>の形をしている。これは暗に外部エンティティの引数が<em>n</em>であることを示している。

外部関数は全ての引数について正格である。

**マーシャリング可能な外部型** <em>fatype</em>によって生成された引数の型<em>at</em><sub>i</sub>は**マーシャリング可能な外部型**でなければならない。すなわち、次のいずれかである。

- 基本外部型である
- マーシャリング可能な外部型に展開される型シノニムである
- <em>T</em> <em>t'</em><sub>1</sub> … <em>t'</em><sub>n</sub>なる型で、<em>T</em>は`newtype`宣言

    <code>newtype <em>T</em> <em>a</em><sub>1</sub> … <em>a</em><sub>n</sub> = <em>N</em> <em>t</em></code>

    によって定義されており、

    - コンストラクタ<em>N</em>は<em>T</em>が使われるところで可視である
    - <em>t[t'<sub>1</sub>/a<sub>1</sub>…t'<sub>n</sub>/a<sub>n</sub>]</em>はマーシャリング可能な外部型である

結果として、`newtype`によって定義された型をそれが定義されたモジュールの外の`foreign`宣言で使うためには、その型は抽象的にエクスポートされてはならない(**訳注**:コンストラクタとともにエクスポートされなければならない)。Cの型と同等のものをHaskellで定義する`Foreign.C.Types`モジュールもこの慣習に従っている。[28](./28-foreign-c-types.md)章をみよ。

**マーシャリング可能な外部結果型** <em>frtype</em>によって生成された結果型<em>rt</em>は**マーシャリング可能な外部結果型**でなければならない。すなわち、次のいずれかである。

- 型`()`である
- `Prelude.IO` <em>t</em>に一致する型である。ここで、<em>t</em>はマーシャリング可能な外部型であるか`()`である
- 基本外部型である
- マーシャリング可能な外部型に展開される型シノニムである
- <em>T</em> <em>t'</em><sub>1</sub> … <em>t'</em><sub>n</sub>なる型で、<em>T</em>は`newtype`宣言

    <code>newtype <em>T</em> <em>a</em><sub>1</sub> … <em>a</em><sub>n</sub> = <em>N</em> <em>t</em></code>

    によって定義されており、

    - コンストラクタ<em>N</em>は<em>T</em>が使われるところで可視である
    - <em>t[t'<sub>1</sub>/a<sub>1</sub>…t'<sub>n</sub>/a<sub>n</sub>]</em>はマーシャリング可能な外部結果型である
